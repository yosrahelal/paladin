def libraries = [
    'core/go/build/libs',
    'core/java/build/libs',
    'toolkit/go/build/libs'
]

def domains = [
    'domains/noto/build/libs',
    'domains/pente/build/libs',
    'domains/zeto/build/libs'
]

def assembleSubprojects = [
    ':core:go',
    ':core:java',
    ':toolkit:go',
    ':domains:pente',
    ':domains:noto',
    ':domains:zeto'
]

ext {
    helpers = [
        lockResource: { task, lockFile ->
            // If two tasks share an output file, they will not be able to run concurrently.
            // This helper creates an empty "lock" file in the root build directory, which allows
            // tasks to use it as a representation of some shared resource.
            def f = new File(task.project.rootProject.buildDir, lockFile)
            task.outputs.file(f)
            task.doLast { f.createNewFile() }
        },

        dumpLogsOnFailure: { task, dockerTaskPath ->
            // If invoked with -PcomposeLogs=true and the given Exec task fails, look up the
            // DockerCompose task specified, and ask it to dump logs.
            task.ignoreExitValue(true)
            task.doLast {
                def execResult = getExecutionResult().get()
                def composeLogs = project.findProperty('composeLogs')
                if (execResult.exitValue != 0 && composeLogs == "true") {
                    def docker = project.tasks.getByPath(dockerTaskPath)
                    println "\nTask '${task.path}' failed. Dumping Docker logs from '${dockerTaskPath}'."
                    docker.dumpLogs()
                }
                execResult.assertNormalExitValue()
            }
        }
    ]
}

task jar {
    enabled = false
}

// Task to copy all executables and binaries to the root-level build/libs directory
task copyLibraries(type: Copy) {
    def libsDir = file("${buildDir}/libs")

    doFirst {
        libsDir.mkdirs()
    }

    libraries.each { dir ->
        from dir
    }
    into libsDir

    outputs.upToDateWhen { false }

    doLast {
        println "Copied executables to ${libsDir}"
    }
}

task copyDomains(type: Copy) {
    def domainsDir = file("${buildDir}/domains")

    doFirst {
        domainsDir.mkdirs()
    }

    domains.each { dir ->
        from dir
    }
    into domainsDir

    outputs.upToDateWhen { false }

    doLast {
        println "Copied domains to ${domainsDir}"
    }
}

// Root assemble task that depends on subproject's assemble tasks
task assemble {
    assembleSubprojects.each { projectPath ->
        dependsOn "${projectPath}:assemble"
    }
}

assemble.finalizedBy(copyLibraries, copyDomains)

defaultTasks 'build'

// Clean task to clean all projects
task clean {
    delete "${buildDir}"
}
